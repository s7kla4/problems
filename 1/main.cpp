/*
 * Способы решения:
 *  1. Полный перебор (O(10^n), n - кол-во знаков в числе)
 *  2. Перебор среди счастливых чисел (O(2^n))
 *  3. Подсчет (O(n^2))
 *
 * Оценим тесты:
 *  В №9 и №10 n = ~60
 *  2^60 = 10^16 => программа будет выполняться несколько минут.
 *  Значит нам подходит только 3 метод.
 *
 * Решение:
 *  Заметим, что число состоит только из двух цифр.
 *  И, в общем сами по себе цифры 2 и 5 никакого смысла не несут.
 *  Заменим двойку нулем, а пятерку единицей. (2 -> 0, 5 -> 1)
 *
 *  2   -> 0
 *  5   -> 1
 *  22  -> 00
 *  25  -> 01
 *  52  -> 10
 *  55  -> 11
 *  222 -> 000
 *  225 -> 001
 *  252 -> 010
 *
 *  При сопоставлении полученных последовательностей с порядковым номером,
 *  получим следующий алгоритм:
 *      1. Заменяем 2 нулями, 5 единицами.          (255225 -> 011001)
 *      2. Вначале последовательности добавляем 1.  (011001 -> 1011001)
 *      3. Переводим в 10ричную систему исчесления. (1011001 -> 89)
 *      4. Отнимаем единицу.                        (89 -> 88)
 *
 */

#include <iostream>

int pow2(int a); // функция возведения 2 в нужную степень

int main() {
    std::string N; // заводим строку, ибо в числе хранить бессмысленно
    std::cin >> N; // считаем строку

    int sum = pow2(N.size()); // добавление 1 в начало
    for (int i = 0; i < N.size(); ++i) {
        if (N[i] == '5') {
            sum += pow2(N.size() - i - 1); // пятерки становятся единицами, но чтобы не переводить в двоичную, переводим сразу
        }
    }

    std::cout << sum-1; // вычитаем единицу и выводим
}
int pow2(int a) {
    int k = 1;
    for (int i = 0; i < a; ++i) {
        k *= 2;
    }
    return k;
}